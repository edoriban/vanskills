#!/usr/bin/env bash
# VanSkills - Install skills to any project
# Usage: ./bin/install [OPTIONS]
#
# Run this from your target project directory, or specify --target

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VANSKILLS_ROOT="$(dirname "$SCRIPT_DIR")"
SKILLS_SOURCE="$VANSKILLS_ROOT/skills"
AGENTS_SOURCE="$VANSKILLS_ROOT/AGENTS.md"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Options
TARGET_DIR=""
SETUP_CLAUDE=false
SETUP_GEMINI=false
SETUP_CODEX=false
SETUP_COPILOT=false
USE_SYMLINKS=true
SELECTED_SKILLS=""
GENERATE_LOCK=true

show_help() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Install VanSkills to a project directory."
    echo ""
    echo "Options:"
    echo "  --target DIR      Target project directory (default: current directory)"
    echo "  --all             Configure all AI assistants"
    echo "  --claude          Configure Claude Code"
    echo "  --gemini          Configure Gemini CLI"
    echo "  --codex           Configure Codex (OpenAI)"
    echo "  --copilot         Configure GitHub Copilot"
    echo "  --copy            Copy files instead of symlinks"
    echo "  --skills LIST     Install specific skills (comma-separated)"
    echo "  --no-lock         Don't generate .vanskills.lock file"
    echo "  --help            Show this help message"
    echo ""
    echo "If no AI assistant flags provided, runs in interactive mode."
    echo ""
    echo "Examples:"
    echo "  $0                                  # Interactive, current directory"
    echo "  $0 --target ~/myproject            # Interactive, specific directory"
    echo "  $0 --all                            # All assistants, current directory"
    echo "  $0 --claude --codex                 # Only Claude and Codex"
    echo "  $0 --skills react-19,typescript    # Only specific skills"
    echo "  $0 --all --skills react-19,nextjs-15,tailwind-4"
}

show_menu() {
    echo -e "${BOLD}Which AI assistants do you use?${NC}"
    echo -e "${CYAN}(Use numbers to toggle, Enter to confirm)${NC}"
    echo ""

    local options=("Claude Code" "Gemini CLI" "Codex (OpenAI)" "GitHub Copilot")
    local selected=(true false false false)

    while true; do
        for i in "${!options[@]}"; do
            if [ "${selected[$i]}" = true ]; then
                echo -e "  ${GREEN}[x]${NC} $((i+1)). ${options[$i]}"
            else
                echo -e "  [ ] $((i+1)). ${options[$i]}"
            fi
        done
        echo ""
        echo -e "  ${YELLOW}a${NC}. Select all"
        echo -e "  ${YELLOW}n${NC}. Select none"
        echo ""
        echo -n "Toggle (1-4, a, n) or Enter to confirm: "

        read -r choice

        case $choice in
            1) selected[0]=$([ "${selected[0]}" = true ] && echo false || echo true) ;;
            2) selected[1]=$([ "${selected[1]}" = true ] && echo false || echo true) ;;
            3) selected[2]=$([ "${selected[2]}" = true ] && echo false || echo true) ;;
            4) selected[3]=$([ "${selected[3]}" = true ] && echo false || echo true) ;;
            a|A) selected=(true true true true) ;;
            n|N) selected=(false false false false) ;;
            "") break ;;
            *) echo -e "${RED}Invalid option${NC}" ;;
        esac

        echo -en "\033[10A\033[J"
    done

    SETUP_CLAUDE=${selected[0]}
    SETUP_GEMINI=${selected[1]}
    SETUP_CODEX=${selected[2]}
    SETUP_COPILOT=${selected[3]}
}

# Extract YAML frontmatter field
extract_field() {
    local file="$1"
    local field="$2"
    awk -v field="$field" '
        /^---$/ { in_frontmatter = !in_frontmatter; next }
        in_frontmatter && $1 == field":" {
            sub(/^[^:]+:[[:space:]]*/, "")
            if ($0 != "" && $0 != ">") {
                gsub(/^["'\''"]|["'\''"]$/, "")
                print
                exit
            }
            getline
            while (/^[[:space:]]/ && !/^---$/) {
                sub(/^[[:space:]]+/, "")
                printf "%s ", $0
                if (!getline) break
            }
            print ""
            exit
        }
    ' "$file" | sed 's/[[:space:]]*$//'
}

# Extract nested metadata field
extract_metadata() {
    local file="$1"
    local field="$2"

    awk -v field="$field" '
        function trim(s) {
            sub(/^[[:space:]]+/, "", s)
            sub(/[[:space:]]+$/, "", s)
            return s
        }

        /^---$/ { in_frontmatter = !in_frontmatter; next }

        in_frontmatter && /^metadata:/ { in_metadata = 1; next }
        in_frontmatter && in_metadata && /^[a-z]/ && !/^[[:space:]]/ { in_metadata = 0 }

        in_frontmatter && in_metadata && $1 == field":" {
            sub(/^[^:]+:[[:space:]]*/, "")

            if ($0 != "") {
                v = $0
                gsub(/^["'\''"]|["'\''"]$/, "", v)
                gsub(/^\[|\]$/, "", v)
                print trim(v)
                exit
            }
        }
    ' "$file"
}

# Extract dependencies array
extract_dependencies() {
    local file="$1"

    awk '
        function trim(s) {
            sub(/^[[:space:]]+/, "", s)
            sub(/[[:space:]]+$/, "", s)
            return s
        }

        /^---$/ { in_frontmatter = !in_frontmatter; next }

        in_frontmatter && /^metadata:/ { in_metadata = 1; next }
        in_frontmatter && in_metadata && /^[a-zA-Z]/ && !/^[[:space:]]/ { in_metadata = 0 }

        in_frontmatter && in_metadata && /^[[:space:]]+dependencies:/ {
            in_deps = 1
            next
        }

        in_frontmatter && in_metadata && in_deps {
            # Exit if we hit a new field (not starting with -)
            if ($0 ~ /^[[:space:]]+[a-zA-Z_-]+:/ && $0 !~ /^[[:space:]]*-/) {
                exit
            }
            # Exit if line doesnt start with spaces
            if ($0 !~ /^[[:space:]]/) {
                exit
            }
            # Process list items
            if ($0 ~ /^[[:space:]]*-[[:space:]]/) {
                line = $0
                sub(/^[[:space:]]*-[[:space:]]*/, "", line)
                line = trim(line)
                gsub(/^["'\''"]|["'\''"]$/, "", line)
                if (line != "" && line !~ /^#/) print line
            }
        }
    ' "$file"
}

# Global arrays for dependency resolution
declare -a _DEP_VISITED=()
declare -a _DEP_RESOLVED=()

# Resolve dependencies recursively
resolve_dependencies() {
    local skill="$1"

    # Skip if already resolved
    if [[ " ${_DEP_RESOLVED[*]} " =~ " ${skill} " ]]; then
        return
    fi

    # Check for circular dependency
    if [[ " ${_DEP_VISITED[*]} " =~ " ${skill} " ]]; then
        echo -e "${YELLOW}Warning: Circular dependency detected for $skill${NC}" >&2
        return
    fi

    _DEP_VISITED+=("$skill")

    local skill_file="$SKILLS_SOURCE/$skill/SKILL.md"
    if [ -f "$skill_file" ]; then
        local deps=$(extract_dependencies "$skill_file")
        while IFS= read -r dep; do
            [ -z "$dep" ] && continue
            resolve_dependencies "$dep"
        done <<< "$deps"
    fi

    _DEP_RESOLVED+=("$skill")
}

create_link_or_copy() {
    local source="$1"
    local target="$2"

    # Remove existing
    if [ -L "$target" ]; then
        rm "$target"
    elif [ -d "$target" ]; then
        mv "$target" "$target.backup.$(date +%s)"
    fi

    if $USE_SYMLINKS; then
        ln -s "$source" "$target"
        echo -e "${GREEN}    -> $target (symlink)${NC}"
    else
        cp -r "$source" "$target"
        echo -e "${GREEN}    -> $target (copy)${NC}"
    fi
}

# Copy specific skills instead of entire directory
copy_selected_skills() {
    local target_skills_dir="$1"
    shift
    local skills=("$@")

    mkdir -p "$target_skills_dir"

    for skill in "${skills[@]}"; do
        local skill_source="$SKILLS_SOURCE/$skill"
        local skill_target="$target_skills_dir/$skill"

        if [ -d "$skill_source" ]; then
            # Remove existing
            if [ -L "$skill_target" ]; then
                rm "$skill_target"
            elif [ -d "$skill_target" ]; then
                rm -rf "$skill_target"
            fi

            if $USE_SYMLINKS; then
                ln -s "$skill_source" "$skill_target"
            else
                cp -r "$skill_source" "$skill_target"
            fi
        fi
    done
}

generate_lock_file() {
    local target="$1"
    shift
    local skills=("$@")

    local lock_file="$target/.vanskills.lock"

    echo "# VanSkills Lock File" > "$lock_file"
    echo "# Auto-generated - do not edit manually" >> "$lock_file"
    echo "# To update: run ~/vanskills/bin/install again" >> "$lock_file"
    echo "" >> "$lock_file"
    echo "generated: $(date -Iseconds)" >> "$lock_file"
    echo "vanskills_version: $(cd "$VANSKILLS_ROOT" && git rev-parse --short HEAD 2>/dev/null || echo "unknown")" >> "$lock_file"
    echo "mode: $([ "$USE_SYMLINKS" = true ] && echo "symlink" || echo "copy")" >> "$lock_file"
    echo "" >> "$lock_file"
    echo "skills:" >> "$lock_file"

    for skill in "${skills[@]}"; do
        local skill_file="$SKILLS_SOURCE/$skill/SKILL.md"
        if [ -f "$skill_file" ]; then
            local version=$(extract_metadata "$skill_file" "version")
            [ -z "$version" ] && version="1.0"
            echo "  - name: $skill" >> "$lock_file"
            echo "    version: \"$version\"" >> "$lock_file"
        fi
    done

    echo -e "${GREEN}    -> .vanskills.lock${NC}"
}

setup_claude() {
    local skills_to_install=("$@")

    echo -e "${YELLOW}Setting up Claude Code...${NC}"

    mkdir -p "$TARGET_DIR/.claude"

    if [ ${#skills_to_install[@]} -gt 0 ]; then
        copy_selected_skills "$TARGET_DIR/.claude/skills" "${skills_to_install[@]}"
        echo -e "${GREEN}    -> .claude/skills/ (${#skills_to_install[@]} skills)${NC}"
    else
        create_link_or_copy "$SKILLS_SOURCE" "$TARGET_DIR/.claude/skills"
    fi

    # Copy AGENTS.md as CLAUDE.md
    if [ -f "$AGENTS_SOURCE" ]; then
        cp "$AGENTS_SOURCE" "$TARGET_DIR/CLAUDE.md"
        echo -e "${GREEN}    -> CLAUDE.md${NC}"
    fi
}

setup_gemini() {
    local skills_to_install=("$@")

    echo -e "${YELLOW}Setting up Gemini CLI...${NC}"

    mkdir -p "$TARGET_DIR/.gemini"

    if [ ${#skills_to_install[@]} -gt 0 ]; then
        copy_selected_skills "$TARGET_DIR/.gemini/skills" "${skills_to_install[@]}"
        echo -e "${GREEN}    -> .gemini/skills/ (${#skills_to_install[@]} skills)${NC}"
    else
        create_link_or_copy "$SKILLS_SOURCE" "$TARGET_DIR/.gemini/skills"
    fi

    # Copy AGENTS.md as GEMINI.md
    if [ -f "$AGENTS_SOURCE" ]; then
        cp "$AGENTS_SOURCE" "$TARGET_DIR/GEMINI.md"
        echo -e "${GREEN}    -> GEMINI.md${NC}"
    fi
}

setup_codex() {
    local skills_to_install=("$@")

    echo -e "${YELLOW}Setting up Codex (OpenAI)...${NC}"

    mkdir -p "$TARGET_DIR/.codex"

    if [ ${#skills_to_install[@]} -gt 0 ]; then
        copy_selected_skills "$TARGET_DIR/.codex/skills" "${skills_to_install[@]}"
        echo -e "${GREEN}    -> .codex/skills/ (${#skills_to_install[@]} skills)${NC}"
    else
        create_link_or_copy "$SKILLS_SOURCE" "$TARGET_DIR/.codex/skills"
    fi

    # Codex uses AGENTS.md natively
    if [ -f "$AGENTS_SOURCE" ]; then
        cp "$AGENTS_SOURCE" "$TARGET_DIR/AGENTS.md"
        echo -e "${GREEN}    -> AGENTS.md${NC}"
    fi
}

setup_copilot() {
    echo -e "${YELLOW}Setting up GitHub Copilot...${NC}"

    mkdir -p "$TARGET_DIR/.github"
    if [ -f "$AGENTS_SOURCE" ]; then
        cp "$AGENTS_SOURCE" "$TARGET_DIR/.github/copilot-instructions.md"
        echo -e "${GREEN}    -> .github/copilot-instructions.md${NC}"
    fi
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --target)
            TARGET_DIR="$2"
            shift 2
            ;;
        --all)
            SETUP_CLAUDE=true
            SETUP_GEMINI=true
            SETUP_CODEX=true
            SETUP_COPILOT=true
            shift
            ;;
        --claude)
            SETUP_CLAUDE=true
            shift
            ;;
        --gemini)
            SETUP_GEMINI=true
            shift
            ;;
        --codex)
            SETUP_CODEX=true
            shift
            ;;
        --copilot)
            SETUP_COPILOT=true
            shift
            ;;
        --copy)
            USE_SYMLINKS=false
            shift
            ;;
        --skills)
            SELECTED_SKILLS="$2"
            shift 2
            ;;
        --no-lock)
            GENERATE_LOCK=false
            shift
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            show_help
            exit 1
            ;;
    esac
done

# Default to current directory
[ -z "$TARGET_DIR" ] && TARGET_DIR="$(pwd)"

# Validate target
if [ ! -d "$TARGET_DIR" ]; then
    echo -e "${RED}Target directory does not exist: $TARGET_DIR${NC}"
    exit 1
fi

# Process selected skills and resolve dependencies
declare -a FINAL_SKILLS=()

if [ -n "$SELECTED_SKILLS" ]; then
    echo -e "${BLUE}Resolving skill dependencies...${NC}"

    # Parse comma-separated skills
    IFS=',' read -ra INITIAL_SKILLS <<< "$SELECTED_SKILLS"

    # Reset global arrays
    _DEP_VISITED=()
    _DEP_RESOLVED=()

    for skill in "${INITIAL_SKILLS[@]}"; do
        skill=$(echo "$skill" | tr -d ' ')
        if [ -d "$SKILLS_SOURCE/$skill" ]; then
            resolve_dependencies "$skill"
        else
            echo -e "${YELLOW}Warning: Skill '$skill' not found, skipping${NC}"
        fi
    done

    FINAL_SKILLS=("${_DEP_RESOLVED[@]}")

    if [ ${#FINAL_SKILLS[@]} -gt ${#INITIAL_SKILLS[@]} ]; then
        echo -e "${GREEN}Added ${#_DEP_RESOLVED[@]} skills (including dependencies)${NC}"
    fi
fi

# Count skills
if [ ${#FINAL_SKILLS[@]} -gt 0 ]; then
    SKILL_COUNT=${#FINAL_SKILLS[@]}
else
    SKILL_COUNT=$(find "$SKILLS_SOURCE" -maxdepth 2 -name "SKILL.md" | wc -l | tr -d ' ')
fi

echo -e "${BLUE}VanSkills Installer${NC}"
echo "==================="
echo ""
echo -e "Source:  ${CYAN}$VANSKILLS_ROOT${NC}"
echo -e "Target:  ${CYAN}$TARGET_DIR${NC}"
echo -e "Skills:  ${CYAN}$SKILL_COUNT${NC}"
echo -e "Mode:    ${CYAN}$([ "$USE_SYMLINKS" = true ] && echo "Symlinks" || echo "Copy")${NC}"

if [ ${#FINAL_SKILLS[@]} -gt 0 ]; then
    echo -e "Selected: ${CYAN}${FINAL_SKILLS[*]}${NC}"
fi
echo ""

# Interactive mode if no flags
if [ "$SETUP_CLAUDE" = false ] && [ "$SETUP_GEMINI" = false ] && [ "$SETUP_CODEX" = false ] && [ "$SETUP_COPILOT" = false ]; then
    show_menu
    echo ""
fi

# Check if at least one selected
if [ "$SETUP_CLAUDE" = false ] && [ "$SETUP_GEMINI" = false ] && [ "$SETUP_CODEX" = false ] && [ "$SETUP_COPILOT" = false ]; then
    echo -e "${YELLOW}No AI assistants selected. Nothing to do.${NC}"
    exit 0
fi

# Run setups
[ "$SETUP_CLAUDE" = true ] && setup_claude "${FINAL_SKILLS[@]}"
[ "$SETUP_GEMINI" = true ] && setup_gemini "${FINAL_SKILLS[@]}"
[ "$SETUP_CODEX" = true ] && setup_codex "${FINAL_SKILLS[@]}"
[ "$SETUP_COPILOT" = true ] && setup_copilot

# Generate lock file
if $GENERATE_LOCK; then
    if [ ${#FINAL_SKILLS[@]} -gt 0 ]; then
        generate_lock_file "$TARGET_DIR" "${FINAL_SKILLS[@]}"
    else
        # Get all skills for lock file
        declare -a all_skills=()
        while IFS= read -r skill_file; do
            skill_name=$(basename "$(dirname "$skill_file")")
            all_skills+=("$skill_name")
        done < <(find "$SKILLS_SOURCE" -maxdepth 2 -name "SKILL.md" -print | sort)
        generate_lock_file "$TARGET_DIR" "${all_skills[@]}"
    fi
fi

# Summary
echo ""
echo -e "${GREEN}Installation complete!${NC}"
echo ""
echo "Configured:"
[ "$SETUP_CLAUDE" = true ] && echo "  - Claude Code:    .claude/skills/ + CLAUDE.md"
[ "$SETUP_CODEX" = true ] && echo "  - Codex (OpenAI): .codex/skills/ + AGENTS.md"
[ "$SETUP_GEMINI" = true ] && echo "  - Gemini CLI:     .gemini/skills/ + GEMINI.md"
[ "$SETUP_COPILOT" = true ] && echo "  - GitHub Copilot: .github/copilot-instructions.md"
echo ""

if [ ${#FINAL_SKILLS[@]} -gt 0 ]; then
    echo -e "${BLUE}Installed skills:${NC}"
    for skill in "${FINAL_SKILLS[@]}"; do
        echo "  - $skill"
    done
    echo ""
fi

if $USE_SYMLINKS && [ ${#FINAL_SKILLS[@]} -eq 0 ]; then
    echo -e "${BLUE}Note: Skills are symlinked. Updates to vanskills will reflect automatically.${NC}"
elif $USE_SYMLINKS; then
    echo -e "${BLUE}Note: Selected skills are symlinked individually.${NC}"
else
    echo -e "${YELLOW}Note: Skills were copied. Run install again to get updates.${NC}"
fi

echo -e "${BLUE}Restart your AI assistant to load the skills.${NC}"
